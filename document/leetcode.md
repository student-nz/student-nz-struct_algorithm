# 1. 两数之和

## 	问题：

​			给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值target 的那 两个整数，

​			并返回它们的数组下标

## 	解决思路：

​			依题意可知

​			给定条件：

​					1）整数数组nums 

​					2）整数目标值target

​			求结果：

​					在该数组中找出和为目标值target的那两个整数

​			本题采用哈希表实现：

​			为什么采用哈希表实现？

​					因为哈希表在数据的存储和查询上几乎可以看做常数时间, 效率就得到了极大的提升

## 	实现思路：

​					首先我们采用的是哈希表实现，就需要借助Java中的HashMap数据结构

​					我的设计思路就是用key保存迭代的数组元素

​					用目标值减去迭代的数组元素，判断该目标值减去迭代的数组元素是否存在于HashMap的key中，

​					如果存在，直接以数组形式返回HashMap的key(存储的数组元素)对应的value(存储的数组元素的索引)和当前迭代元素索引，

​					即找到在该数组中找出和为目标值target的那两个整数的数组下标并返回

​	

# 	2. 两数相加

## 		问题：

​					给你两个非空的链表, 表示两个非负的整数

​					它们每位数字都是按照 逆序的方式存储的, 并且每个节点只能存储 一位数字

​					请你将两个数相加, 并以相同形式返回一个表示和的链表

## 		解决思路：

​					依题意可知：

​					给定条件：

​						1）两个非空的链表，表示两个非负的整数

​						2）每位数字按照 逆序方式存储，并且每个节点只能存储 一位数字

​					求结果：

​						两个数相加并以相同形式返回一个表示和的链表

## 		实现思路：

​						首先我们需要先准备8个标识符ca、n1和n2、n、c1、c2、node、pre

​						分别进行记录进位值，两个结点当前数字，两个头结点的值之和与进位值相加之和，两个头结点，新建结点，上一个结点

​						如果两个头结点其中一个不为空，获取两个头结点的值，再将两个头结点的值之和与进位值相加赋值给n

​						新建结点, 存取 n % 10 取模后的值,新建结点的下一个结点指向上一个结点，求进位值, 判断c1、c2是否为空，

​						不为空，指向下一个结点，继续下一次循环判断，直到c1和c2都为空 ，此时循环结束，如果进位值还保存了个1，

​						则pre变为老的node，新建一个节点重新赋值给node，即得到新的node，此时两链表相加完毕到一个标识和的链中，

​						但是此时链表是因为两链表数字是逆序方式存储且相加的，此时，我们就需要反转标识和的链表进行返回给我们调用者

​						这样我们就能得到我们相应的结果

​						反转链表思路：	

​							由于该题解决方案是采用单链表解决方案，反转单链链表就是上一个结点和下一个结点互换方向

​							此时我们就需要两个标识符pre和next分别标记上一个结点和下一个结点，如果头结点不为空，

​							先用next记录当前头结点下一个结点，以便作为下一次反转的头结点

​							然后再将当前头结点的下一个结点指向上一个结点，

​							当前头结点就变为了上一个结点，头结点就变为了当前结点的下一个结点

​							即next已经记录好的那个头结点的下一个结点

# 3. 无重复字符的最长子串

## 问题：

​				给定一个字符串 s, 请你找出其中不含有重复字符的最长子串的长度

## 解决思路：

​				依题意可知：

​				给定条件：

​					1）给定一个字符串s

​				求结果：

​					找出其中不含有重复字符的最长子串的长度

## 实现思路：

​				首先，我先将传入进来的字符串进行判断

​				1. 如果字符串为空或者为空字符串，直接返回0，因为字符串本身长度都为0，那么最长子串长度必为0

​				2. 否则，先将字符串转换为字符数组，便于后续依次进行遍历访问每一个字符

​				3. 创建一个数组长度为256的map整型数组进行映射上一个字符所在位置

​					由于刚开始并没有访问字符数组中的每一个元素，即先将这256个字符的上一次出现位置都记录为-1，代表未出现

​					采用256整型数组长度原因：

​							因为在ASCII编码方案中一个字符占1字节，总共256字符，同时，ASCII码与整型有对应关系

​							所以采取数组长度为256的整型数组，用于记录256个字符映射位置

​				4. 三个标识符len、pre、cur分别用于记录

​					不含有重复字符串的最长子串的长度、当前字符上一次出现位置、当前字符所在位置到上一个所在最近位置的长度

​				5. 获取pre和cur的最大值，该最大值就是新的不含有重复字符串的最长子串的长度

​				6. map记录当前字符所在字符串位置

# 4. 寻找两个正序数组的中位数（不会）

## 问题：

​	给定两个大小分别为 m和 n的正序（从小到大）数组 `nums1` 和 `nums2`。

​	请你找出并返回这两个正序数组的中位数				

​	算法的时间复杂度应该为 O(log (m+n))

## 解决思路：

​	依题意可知：

​	给定条件：
​		1）两个大小分别为 m 和 n 的正序数组num和num2

​	求结果：

​		返回这两个正序数组的中位数

## 实现思路：

​		二分法实现：

​		1. 寻找中位数其实就是寻找一组数中间位置的数，这样就可以将问题转化为求第`k`小元素

​		2. k为中位数的位置。数组长度为奇数或为偶数时，计算方法稍有不同，但是偶数情况的中位数为第`k`小和第`k+1`小的元素求和再除2

​		3. 这里两个有序数组A和B，利用二分法的思想，首先取k=k/2，比较A[k\2 - 1]和B[k\2 - 1]，对于这两个中的较小值，

​			最多只会有 ( k / 2 − 1 ) + ( k / 2 − 1 ) ≤ k − 2 (k/2-1)+(k/2-1) \leq k-2 (k/2−1)+(k/2−1)≤k−2个元素比它小，

​			那么它就不能是第 k小的数了。可以直接排除掉

​		4. 这里会出现三种情况：

​			1）A[k\2 - 1] > B[k\2 - 1]，此时排除掉`A[0]`到A[k\2 - 1]的元素，它们都不可能是第k小的元素。

​			2）A[k\2 - 1] < B[k\2 - 1]，此时排除掉`B[0]`到B[k\2 - 1]的元素，它们都不可能是第`k`小的元素

​			3）A[k\2 - 1] = B[k\2 - 1]，可以归到第一种情况处理

​		这样处理一轮，我们就排除了一些元素，接下来需要减少k的值(因为我们排除的都是不大于第k小元素的)，

​		在排除后的数组上继续寻找第k小元素，注意，这里的k值不一定是k-k/2。

​		有以下三种特殊情况：

​			1）若A[k\2 - 1]或B[k\2 - 1]越界，可以选择越界数组的最后一个元素和另一个数组作比较，防止程序出错。

​			此时需要按照实际排除的元素个数来减少k的值，不能直接k -= k/2;

​			2）如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 *k* 小的元素

​			3）若k==1，返回排除过后两个数组首元素的较小值即为所求

# 5. 最长回文数

## 问题：

​		给你一个字符串 s，找到 s 中最长的回文子串

## 解题思路：

​		依题意可知：

# 509. 斐波那契数列

## 问题：

​		斐波那契数 （通常用F(n)表示）形成的序列称为 斐波那契数列，该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和

## 解题思路：

​		依题意知：

​		給定条件：

​			后面的每一项数字都是前面两项数字的和

​		求结果：

​			求斐波那契数

## 实现思路：

​	1. 递归法：时间复杂度O(2^n)

​	2. 迭代法：时间复杂度O(n)

​	3. 通项公式法：时间复杂度O(1)

​			