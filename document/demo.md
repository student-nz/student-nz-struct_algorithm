# 算法热身前知识

## 	原码：

​			正数的原码是本身,符号位为0

​			负数的原码,符号位为1

## 	反码：

​			正数反码是它本身

​			负数反码是保留符号位,其他位取反

## 	补码：

​			正数的补码是它本身

​			负数的补码是它的反码加一

## 	有符号位整型：

​			最高位(第0位) ，符号位(标识正负 -> 0(非负数) 1(负数)

​			 其余位(1~31位) ，数值位(取值范围 -> -2^31 ~ 2^31 - 1)

## 	无符号位整型：

​			其余位(0~31位)，数值位(取值范围 -> 0 ~ 2^32 - 1)

## 	Java中的整型：

​			Java中的 int类型(整型)指的是有符号整型

## 	整数在底层存储形式：

​			整数在计算机底层都是以补码二进制形式存

## 	移位运算符：

​			|：运算规则：只要两个数中的⼀个为1，结果就为1

​			&：运算规则：同为1，结果为1，否则为0

​			^：运算规则：不同为1，相同为0，即 0 ^ 0=0

​			<<：左移位

​			>> ：带符号右移，如果是正数就补0，负数就补1

​			>>>：不带符号右移，无论正数还是负数，始终补0

​			~：取反，对数值的二进制位进行取反

# 1）打印整型二进制

## 分析问题：

​	打印整型二进制

## 实现思路：

​	一个整型占有 4 字节 总共 32 位 信息,利用for循环按顺序遍历该整型数字所有位信息并打印

​	利用到了 位运算符 & 和 <<				

# 2）求1! + 2! + 3! + 4! + . . .n!的和

## 实现思路：

#### 	方式一： 加乘分开法

#### 	方式二：乘加结合法

# 3）数组相关算法

## 1. 选择排序算法

#### 算法思想：

如果有N个元素需要排序，那么首先从N个元素中找到最小的那个元素与第0位置上的元素交换，然后再从剩下的N-1个元素中找到最小的元素与第1位置上的元素交换，之后再从剩下的N-2个元素中找到最小的元素与第2位置上的元素交换，.......直到所有元素都排序好

## 2. 冒泡排序算法

### 算法思想：

重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来

走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成

## 3. 插入排序算法

### 算法思想：

通过构建有序序列, 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

### 实现思路：

#### 方式一：while循环实现

#### 方式二：for循环实现

## 4. 生成随机数组算法

​	1. 生成一个随机数组arr，arr长度[0,maxSize],arr中的每个值[0,maxValue]

​	2. 生成随机数组，且相邻数不相等，arr长度[0,maxSize],arr中的每个值[0,maxValue]

## 5. 拷贝数组算法

## 6. 判断两个数组是否相等算法

## 7. 判断一个元素是否有序

## 8. 判断一个数组是否升序

## 9. 判断一个数组是否降序